/*
 * Venus
 * Copyright 2013 LinkedIn
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *     Unless required by applicable law or agreed to in writing,
 *     software distributed under the License is distributed on an "AS
 *     IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *     express or implied.   See the License for the specific language
 *     governing permissions and limitations under the License.
 **/

// Parse code coverage data
'use strict';

var fs     = require('fs'),
    logger = require('./util/logger'),
    rmrf   = require('rmrf');

function CodeCoverage() {}

/**
 * Parse raw code coverage data and generate friendly metrics
 * @param   {Object} data raw code coverage generated by instrumentation tool (istanbul)
 * @returns {Object}      parsed data for all filepaths
 */
CodeCoverage.prototype.parse = function (data) {
  var results = {};

  Object.keys(data).forEach(function (filePath) {
    results[filePath] = this.parseFileData(filePath, data[filePath]);
  }, this);

  return results;
};

/**
 * Parses coverage data for a given file
 * @param  {string} filePath file location
 * @param  {Object} data     the raw, unparsed data for the given file
 * @return {Object}          the parsed data for the given filepath (path, statements, functions, branches)
 */
CodeCoverage.prototype.parseFileData = function (filePath, data) {
  var result = {
    path: filePath,
    statements: this.parseStatements(data),
    functions: this.parseFunctions(data),
    branches: this.parseBranches(data)
  };

  return result;
};

/**
 * Provides the coverage percentage for a given token (functions, statements, branches)
 * @param  {Object} data token data for which coverage will be assessed
 * @return {Object}      An object containing the coverage percentage (in the 'percent' property)
 */
CodeCoverage.prototype.parseTokenCoverage = function (data) {
  var total = 0,
      covered = 0,
      tokens = {};

  Object.keys(data).forEach(function (token) {
    countTokenData(data[token]);
  });

  function countTokenData(tokenValue) {
    if (typeof tokenValue === 'number') {
      total = total + 1;

      if (tokenValue > 0) {
        covered = covered + 1;
      }
    } else if (Array.isArray(tokenValue)) {
      tokenValue.forEach(function (tokenValue) {
        countTokenData(tokenValue);
      });
    }
  }


  return {
    percent: covered / total
  };

};

/**
 * Parses statement coverage
 * @param  {Object} data file data to parse
 * @return {Object}      An object containing the statement coverage percentage (in the 'percent' property)
 */
CodeCoverage.prototype.parseStatements = function (data) {
  return this.parseTokenCoverage(data.s);
};

/**
 * Parses function coverage
 * @param  {Object} data file data to parse
 * @return {Object}      An object containing the function coverage percentage (in the 'percent' property)
 */
CodeCoverage.prototype.parseFunctions = function (data) {
  return this.parseTokenCoverage(data.f);
};

/**
 * Parses branch coverage
 * @param  {object} data file data to parse
 * @return {object}      An object containing the branch coverage percentage (in the 'percent' property)
 */
CodeCoverage.prototype.parseBranches = function (data) {
  return this.parseTokenCoverage(data.b);
};

/**
 * Writes coverage summary to a file
 * @param  {Object}    data                  Coverage data to be written
 * @param  {Boolean}   isCodeCoverageEnabled If enabled, venus will write coverage data to a file
 * @param  {String}    outputPath            Coverage data is written to a file at this location
 * @return {Undefined}                       undefined
 */
CodeCoverage.prototype.writeSummary = function (data, isCodeCoverageEnabled, outputPath) {

  // Write code coverage data
  var istanbul  = require('istanbul');
  var reporter  = new istanbul.Reporter();
  var collector = new istanbul.Collector();

  rmrf('./coverage');

  data.forEach(function (d) {
    collector.add(d);
  });

  reporter.add('html');
  reporter.add('lcov');
  reporter.add('text-summary');
  reporter.add('cobertura');
  reporter.add('clover');
  reporter.add('json');

  reporter.write(collector, true, function () {
    logger.info('Wrote code coverage data to ./coverage');
  });

  var fileOutput =
    ['source file, total lines, code coverage, lines covered, lines not covered'];

  outputPath = outputPath || 'coverage.csv';

  data.forEach(function (obj) {
    var fileData = obj[Object.keys(obj)[0]],
        path = fileData.path,
        statements = fileData.statementMap,
        coveredLines = [],
        line,
        fileContents,
        totalLinesInFile,
        coveragePercentage,
        uncoveredLines = [];

    Object.keys(statements).forEach(function (key) {
      var statement = statements[key],
          startLine = statement.start.line,
          endLine   = statement.end.line;

      for (line = startLine; line <= endLine; line++) {
        if (coveredLines.indexOf(line) === -1) {
          coveredLines.push(line);
        }
      }

    });

    fileContents = fs.readFileSync(path).toString();
    totalLinesInFile = fileContents.split('\n').length - 1;

    for (line = 1; line <= totalLinesInFile; line++) {
      if (coveredLines.indexOf(line) === -1) {
        uncoveredLines.push(line);
      }
    }

    coveragePercentage = (coveredLines.length / totalLinesInFile).toPrecision(2);

    fileOutput.push([
      path,
      totalLinesInFile,
      coveragePercentage,
      coveredLines.join(' '),
      uncoveredLines.join(' ')
    ].join(','));
  });

  // If command line option for code coverage is enabled (-c, --coverage), write coverage file to the file system
  if (isCodeCoverageEnabled) {
    fs.writeFileSync(outputPath, fileOutput.join('\n'));
  }
};

module.exports = new CodeCoverage();
